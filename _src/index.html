<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8">
		<title></title>
		<link rel="stylesheet" href="css/style.css">
	</head>
	<body>
		<include src="./_src/blocks/section/section.html"></include>
		<script>
    const container = document.getElementById('container');
    const svg = document.getElementById('svg');
    const inner = document.getElementById('inner');

    const viewBox = svg.viewBox.baseVal;
    const svgWidth = viewBox.width;
    const svgHeight = viewBox.height;

    let scale = 1; // Стартовый масштаб = 1
    let translate = { x: 0, y: 0 };
    let isDragging = false;
    let start = { x: 0, y: 0 };

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function getMinScale() {
      return container.clientWidth / svgWidth; // всё ещё пригодится для ограничения
    }

    function updateTransform() {
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;

      const scaledWidth = svgWidth * scale;
      const scaledHeight = svgHeight * scale;

      const minX = Math.min(0, containerWidth - scaledWidth);
      const minY = Math.min(0, containerHeight - scaledHeight);

      const maxX = 0;
      const maxY = 0;

      translate.x = clamp(translate.x, minX, maxX);
      translate.y = clamp(translate.y, minY, maxY);

      inner.style.transform = `translate(${translate.x}px, ${translate.y}px) scale(${scale})`;
    }

    svg.addEventListener("wheel", (e) => {
      e.preventDefault();

      const zoomSpeed = 0.0005;
      const oldScale = scale;
      scale += -e.deltaY * zoomSpeed;

      const minScale = getMinScale();
      scale = clamp(scale, minScale, 4);

      const rect = svg.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const dx = mouseX - translate.x;
      const dy = mouseY - translate.y;

      translate.x -= dx * (scale / oldScale - 1);
      translate.y -= dy * (scale / oldScale - 1);

      updateTransform();
    });

    svg.addEventListener("mousedown", (e) => {
      isDragging = true;
      start = { x: e.clientX - translate.x, y: e.clientY - translate.y };
      svg.style.cursor = "grabbing";
    });

    window.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      translate = {
        x: e.clientX - start.x,
        y: e.clientY - start.y
      };
      updateTransform();
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
      svg.style.cursor = "grab";
    });

    function centerInitialView() {
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;

      const scaledWidth = svgWidth * scale;
      const scaledHeight = svgHeight * scale;

      translate.x = (containerWidth - scaledWidth) / 2;
      translate.y = (containerHeight - scaledHeight) / 2;

      updateTransform();
    }

    window.addEventListener("resize", centerInitialView);
    centerInitialView(); // Центрируем при загрузке
  </script>
	</body>
</html>